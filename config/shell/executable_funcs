# shellcheck shell=bash source=/dev/null

# Function to switch betweeen background and foreground programs
function fg-bg() {
    if [[ $#BUFFER -eq 0 ]]; then
        local backgroundProgram="$(jobs | tail -n 1 | awk '{print $4}')"
        case "$backgroundProgram" in
            "nc"|"ncat"|"netcat"|"resize-netcat-listener"|"rnc")
                # Make sure that /dev/tty is given to the stty command by doing </dev/tty
                terminal-size-clip < /dev/tty
                stty raw -echo < /dev/tty; fg
                ;;
            *)
                fg
                ;;
        esac
    else
        zle push-input
    fi
}



# demolish any --user installed cabal packages.
cabalwipe() {
    rm -rf "$HOME/.cabal/packages"/*/*
    rm -rf "$HOME/.cabal/bin"/*
    rm -rf "$HOME/.ghc"
}

# filegrep 'foo.*' ./some/dir, greps all files in the given dir for the
# given regex
filegrep() {
    local dir="$2" regex="$1"
    find "$dir" -type f ! -wholename '*/.svn/*' ! -wholename '*/.git/*' -exec grep --color=auto -- "$regex" {} \+
}

# combine pdfs into one using ghostscript
combinepdf() {
    _have gs       || return 1
    [[ $# -ge 2 ]] || return 1

    local out="$1"; shift

    gs -dBATCH -dNOPAUSE -q -sDEVICE=pdfwrite -sOutputFile="$out" "$@"
}

# add by artist to mpc
addartist() {
    _have mpc || return 1

    mpc search artist "$*" | mpc add &>/dev/null
    mpc play
}

# make a thumb %20 the size of a pic
thumbit() {
    _have mogrify || return 1

    for pic; do
        case "$pic" in
            *.jpg)  thumb="${pic/.jpg/-thumb.jpg}"   ;;
            *.jpeg) thumb="${pic/.jpeg/-thumb.jpeg}" ;;
            *.png)  thumb="${pic/.png/-thumb.png}"   ;;
            *.bmp)  thumb="${pic/.bmp/-thumb.bmp}"   ;;
        esac

        [[ -z "$thumb" ]] && return 1

        cp "$pic" "$thumb" && mogrify -resize 10% "$thumb"
    done
}

# rip a dvd with handbrake
hbrip() {
    _have HandBrakeCLI || return 1
    [[ -n "$1" ]]      || return 1

    local name="$1" out drop="$HOME/Videos"; shift
    [[ -d "$drop" ]] || mkdir -p "$drop"

    out="$drop/$name.m4v"

    echo "rip /dev/sr0 --> $out"
    HandBrakeCLI --main-feature -m -s scan -F -N eng -Z High Profile "$@" -i /dev/sr0 -o "$out" 2>/dev/null
    echo
}

# convert media to ipad format with handbrake
hbconvert() {
    _have HandBrakeCLI || return 1
    [[ -n "$1" ]]      || return 1

    local in="$1" out drop="$HOME/Videos/converted"; shift
    [[ -d "$drop" ]] || mkdir -p "$drop"

    out="$drop/$(basename "${in%.*}").mp4"

    echo "convert $in --> $out"
    HandBrakeCLI -Z iPad "$@" -i "$in" -o "$out" 2>/dev/null
    echo
}

# simple spellchecker, uses /usr/share/dict/words
spellcheck() {
    [[ -f /usr/share/dict/words ]] || return 1

    for word; do
        if grep -Fqx "$word" /usr/share/dict/words; then
            echo -e "\e[1;32m$word\e[0m" # green
        else
            echo -e "\e[1;31m$word\e[0m" # red
        fi
    done
}

# go to google for anything
google() {
    [[ -z "$BROWSER" ]] && return 1

    local term="${*:-$(xclip -o)}"

    $BROWSER "http://www.google.com/search?q=${term// /+}" &>/dev/null &
}

# go to google for a definition
define() {
    _have w3m     || return 1
    _have mpv || return 1

    local word="$*"

    w3m -dump "http://www.google.com/search?q=define%20${word// /_}" | awk '/^     1./,/^        More info >>/'
    mpv "http://ssl.gstatic.com/dictionary/static/sounds/de/0/${word// /_}.mp3" &>/dev/null
}

# grep by paragraph
grepp() { perl -00ne "print if /$1/i" < "$2"; }

# pull a single file out of an achive, stops on first match. useful for
# .PKGINFO files in .pkg.tar.[gx]z files.
pullout() {
    _have bsdtar || return 1

    local opt

    case "$2" in
        *gz) opt='-qxzf' ;;
        *xz) opt='-qxJf' ;;
        *)   return 1    ;;
    esac

    bsdtar $opt "$2" "$1"
}

# recursively 'fix' dir/file perm
fix() {
    local dir

    for dir; do
        find "$dir" -type d -exec chmod 755 {} \;
        find "$dir" -type f -exec chmod 644 {} \;
    done
}

# print docs to default printer in reverse page order
printr() {
    _have enscript || return 1

    # stdin?
    if [[ -z "$*" ]]; then
        cat | enscript -p - | psselect -r | lp
        return 0
    fi

    local file

    for file; do
        enscript -p - "$file" | psselect -r | lp
    done
}

# set an ad-hoc GUI timer
timer() {
    $_isxrunning || return 1
    _have zenity || return 1

    local N="${1:-5m}"; shift

    (sleep $N && zenity --info --title="Time's Up" --text="${*:-DING}") &
    echo "timer set for $N"
}

# send an attachment from CLI
send() {
    _have mutt    || return 1
    [[ -f "$1" ]] || return 1
    [[ -z "$2" ]] || return 1

    echo 'Please see attached.' | mutt -s "File: $1" -a "$1" -- "$2"
}

# run a bash script in 'debug' mode
debug() {
    local script="$1"; shift

    if _have "$script"; then
        PS4='+$LINENO:$FUNCNAME: ' bash -x "$script" "$@"
    fi
}

# go to a directory or file's parent
goto() { [[ -d "$1" ]] && cd "$1" || cd "$(dirname "$1")"; }

# copy and follow
cpf() { cp "$@" && goto "$_"; }

# move and follow
mvf() { mv "$@" && goto "$_"; }

# print the url to a manpage
webman() { echo "http://unixhelp.ed.ac.uk/CGI/man-cgi?$1"; }

# Simple calculator
calc() {
	  local result=""
	  result="$(printf "scale=10;$*\n" | bc --mathlib | tr -d '\\\n')"
	  #						└─ default (when `--mathlib` is used) is 20

	  if [[ "$result" == *.* ]]; then
		    # improve the output for decimal numbers
		    printf "$result" |
		        sed -e 's/^\./0./'		  `# add "0" for cases like ".5"` \
			          -e 's/^-\./-0./'	  `# add "0" for cases like "-.5"`\
			          -e 's/0*$//;s/\.$//';  # remove trailing zeros
	  else
		    printf "$result"
	  fi
	  printf "\n"
}

# Create a new directory and enter it
mkd() {
	  mkdir -p "$@" && cd "$@"
}

# Make a temporary directory and enter it
tmpd() {
	  if [ $# -eq 0 ]; then
		    dir=`mktemp -d` && cd $dir
	  else
		    dir=`mktemp -d -t $1.XXXXXXXXXX` && cd $dir
	  fi
}

# Create a .tar.gz archive, using `zopfli`, `pigz` or `gzip` for compression
targz() {
	  local tmpFile="${@%/}.tar"
	  tar -cvf "${tmpFile}" --exclude=".DS_Store" "${@}" || return 1

	  size=$(
	      stat -f"%z" "${tmpFile}" 2> /dev/null; # OS X `stat`
	      stat -c"%s" "${tmpFile}" 2> /dev/null # GNU `stat`
	      )

	  local cmd=""
	  if (( size < 52428800 )) && hash zopfli 2> /dev/null; then
		    # the .tar file is smaller than 50 MB and Zopfli is available; use it
		    cmd="zopfli"
	  else
		    if hash pigz 2> /dev/null; then
			      cmd="pigz"
		    else
			      cmd="gzip"
		    fi
	  fi

	  echo "Compressing .tar using \`${cmd}\`…"
	  "${cmd}" -v "${tmpFile}" || return 1
	  [ -f "${tmpFile}" ] && rm "${tmpFile}"
	  echo "${tmpFile}.gz created successfully."
}

# Determine size of a file or total size of a directory
fs() {
	  if du -b /dev/null > /dev/null 2>&1; then
		    local arg=-sbh
	  else
		    local arg=-sh
	  fi
	  if [[ -n "$@" ]]; then
		    du $arg -- "$@"
	  else
		    du $arg .[^.]* *
	  fi
}

# Use Git’s colored diff when available
hash git &>/dev/null
if [ $? -eq 0 ]; then
	  diff() {
		    git diff --no-index --color-words "$@"
	  }
fi

# Create a data URL from a file
dataurl() {
	  local mimeType=$(file -b --mime-type "$1")
	  if [[ $mimeType == text/* ]]; then
		    mimeType="${mimeType};charset=utf-8"
	  fi
	  echo "data:${mimeType};base64,$(openssl base64 -in "$1" | tr -d '\n')"
}

# Create a git.io short URL
gitio() {
	  if [ -z "${1}" -o -z "${2}" ]; then
		    echo "Usage: \`gitio slug url\`"
		    return 1
	  fi
	  curl -i http://git.io/ -F "url=${2}" -F "code=${1}"
}

# Start an HTTP server from a directory, optionally specifying the port
server() {
	  local port="${1:-8000}"
	  sleep 1 && open "http://localhost:${port}/" &
	  # Set the default Content-Type to `text/plain` instead of `application/octet-stream`
	  # And serve everything as UTF-8 (although not technically correct, this doesn’t break anything for binary files)
	  python -c $'import SimpleHTTPServer;\nmap = SimpleHTTPServer.SimpleHTTPRequestHandler.extensions_map;\nmap[""] = "text/plain";\nfor key, value in map.items():\n\tmap[key] = value + ";charset=UTF-8";\nSimpleHTTPServer.test();' "$port"
}

# Compare original and gzipped file size
gz() {
	  local origsize=$(wc -c < "$1")
	  local gzipsize=$(gzip -c "$1" | wc -c)
	  local ratio=$(echo "$gzipsize * 100 / $origsize" | bc -l)
	  printf "orig: %d bytes\n" "$origsize"
	  printf "gzip: %d bytes (%2.2f%%)\n" "$gzipsize" "$ratio"
}

# Syntax-highlight JSON strings or files
# Usage: `json '{"foo":42}'` or `echo '{"foo":42}' | json`
json() {
	  if [ -t 0 ]; then # argument
		    python -mjson.tool <<< "$*" | pygmentize -l javascript
	  else # pipe
		    python -mjson.tool | pygmentize -l javascript
	  fi
}

# Run `dig` and display the most useful info
digga() {
	  dig +nocmd "$1" any +multiline +noall +answer
}

# Query Wikipedia via console over DNS
mwiki() {
	  dig +short txt "$*".wp.dg.cx
}

# UTF-8-encode a string of Unicode symbols
escape() {
	  printf "\\\x%s" $(printf "$@" | xxd -p -c1 -u)
	  # print a newline unless we’re piping the output to another program
	  if [ -t 1 ]; then
		    echo ""; # newline
	  fi
}

# Decode \x{ABCD}-style Unicode escape sequences
unidecode() {
	  perl -e "binmode(STDOUT, ':utf8'); print \"$@\""
	  # print a newline unless we’re piping the output to another program
	  if [ -t 1 ]; then
		    echo ""; # newline
	  fi
}

# Get a character’s Unicode code point
codepoint() {
	  perl -e "use utf8; print sprintf('U+%04X', ord(\"$@\"))"
	  # print a newline unless we’re piping the output to another program
	  if [ -t 1 ]; then
		    echo ""; # newline
	  fi
}

# Show all the names (CNs and SANs) listed in the SSL certificate
# for a given domain
getcertnames() {
	  if [ -z "${1}" ]; then
		    echo "ERROR: No domain specified."
		    return 1
	  fi

	  local domain="${1}"
	  echo "Testing ${domain}…"
	  echo ""; # newline

	  local tmp=$(echo -e "GET / HTTP/1.0\nEOT" \
		                   | openssl s_client -connect "${domain}:443" 2>&1)

	  if [[ "${tmp}" = *"-----BEGIN CERTIFICATE-----"* ]]; then
		    local certText=$(echo "${tmp}" \
			                          | openssl x509 -text -certopt "no_header, no_serial, no_version, \
			no_signame, no_validity, no_issuer, no_pubkey, no_sigdump, no_aux")
		    echo "Common Name:"
		    echo ""; # newline
		    echo "${certText}" | grep "Subject:" | sed -e "s/^.*CN=//"
		    echo ""; # newline
		    echo "Subject Alternative Name(s):"
		    echo ""; # newline
		    echo "${certText}" | grep -A 1 "Subject Alternative Name:" \
			      | sed -e "2s/DNS://g" -e "s/ //g" | tr "," "\n" | tail -n +2
		    return 0
	  else
		    echo "ERROR: Certificate not found."
		    return 1
	  fi
}

# `o` with no arguments opens the current directory, otherwise opens the given
# location
o() {
	  if [ $# -eq 0 ]; then
		    xdg-open .	> /dev/null 2>&1
	  else
		    xdg-open "$@" > /dev/null 2>&1
	  fi
}

# `tre` is a shorthand for `tree` with hidden files and color enabled, ignoring
# the `.git` directory, listing directories first. The output gets piped into
# `less` with options to preserve color and line numbers, unless the output is
# small enough for one screen.
tre() {
	  tree -aC -I '.git' --dirsfirst "$@" | less -FRNX
}

# Call from a local repo to open the repository on github/bitbucket in browser
repo() {
	  local giturl=$(git config --get remote.origin.url | sed 's/git@/\/\//g' | sed 's/.git$//' | sed 's/https://g' | sed 's/:/\//g')
	  if [[ $giturl == "" ]]; then
		    echo "Not a git repository or no remote.origin.url is set."
	  else
		    local gitbranch=$(git rev-parse --abbrev-ref HEAD)
		    local giturl="http:${giturl}"

		    if [[ $gitbranch != "master" ]]; then
			      if echo "${giturl}" | grep -i "bitbucket" > /dev/null ; then
				        local giturl="${giturl}/branch/${gitbranch}"
			      else
				        local giturl="${giturl}/tree/${gitbranch}"
			      fi
		    fi

		    echo $giturl
		    open $giturl
	  fi
}

# Get colors in manual pages
man() {
	  env \
		    LESS_TERMCAP_mb=$(printf "\e[1;31m") \
		    LESS_TERMCAP_md=$(printf "\e[1;31m") \
		    LESS_TERMCAP_me=$(printf "\e[0m") \
		    LESS_TERMCAP_se=$(printf "\e[0m") \
		    LESS_TERMCAP_so=$(printf "\e[1;44;33m") \
		    LESS_TERMCAP_ue=$(printf "\e[0m") \
		    LESS_TERMCAP_us=$(printf "\e[1;32m") \
		    man "$@"
}

# Use feh to nicely view images
openimage() {
	  local types='*.jpg *.JPG *.png *.PNG *.gif *.GIF *.jpeg *.JPEG'

	  cd $(dirname "$1")
	  local file=$(basename "$1")

	  feh -q $types --auto-zoom \
		    --sort filename --borderless \
		    --scale-down --draw-filename \
		    --image-bg black \
		    --start-at "$file"
}

# get dbus session
dbs() {
	  local t=$1
	  if [[  -z "$t" ]]; then
		    local t="session"
	  fi

	  dbus-send --$t --dest=org.freedesktop.DBus \
		          --type=method_call	--print-reply \
		          /org/freedesktop/DBus org.freedesktop.DBus.ListNames
}

# check if uri is up
isup() {
	  local uri=$1

	  if curl -s --head  --request GET "$uri" | grep "200 OK" > /dev/null ; then
		    notify-send --urgency=critical "$uri is down"
	  else
		    notify-send --urgency=low "$uri is up"
	  fi
}

# build go static binary from root of project
gostatic(){
	  local dir=$1
	  local arg=$2

	  if [[ -z $dir ]]; then
		    dir=$(pwd)
	  fi

	  local name=$(basename "$dir")
	  (
	      cd $dir
	      export GOOS=linux
	      echo "Building static binary for $name in $dir"

	      case $arg in
		        "netgo")
			          set -x
			          go build -a \
				           -tags 'netgo static_build' \
				           -installsuffix netgo \
				           -ldflags "-w" \
				           -o "$name" .
			          ;;
		        "cgo")
			          set -x
			          CGO_ENABLED=1 go build -a \
				                   -tags 'cgo static_build' \
				                   -ldflags "-w -extldflags -static" \
				                   -o "$name" .
			          ;;
		        *)
			          set -x
			          CGO_ENABLED=0 go build -a \
				                   -installsuffix cgo \
				                   -ldflags "-w" \
				                   -o "$name" .
			          ;;
	      esac
	  )
}

# go to a folder easily in your gopath
gogo(){
	  local d=$1

	  if [[ -z $d ]]; then
		    echo "You need to specify a project name."
		    return 1
	  fi

	  if [[ "$d" == github* ]]; then
		    d=$(echo $d | sed 's/.*\///')
	  fi
	  d=${d%/}

	  # search for the project dir in the GOPATH
	  local path=( `find "${GOPATH}/src" \( -type d -o -type l \) -iname "$d"  | awk '{print length, $0;}' | sort -n | awk '{print $2}'` )

	  if [ "$path" == "" ] || [ "${path[*]}" == "" ]; then
		    echo "Could not find a directory named $d in $GOPATH"
		    echo "Maybe you need to 'go get' it ;)"
		    return 1
	  fi

	  # enter the first path found
	  cd "${path[0]}"
}

golistdeps(){
	  (
	      if [[ ! -z "$1" ]]; then
		        gogo $@
	      fi

	      go list -e -f '{{join .Deps "\n"}}' ./... | xargs go list -e -f '{{if not .Standard}}{{.ImportPath}}{{end}}'
	  )
}

# get the name of a x window
xname(){
	  local window_id=$1

	  if [[ -z $window_id ]]; then
		    echo "Please specifiy a window id, you find this with 'xwininfo'"

		    return 1
	  fi

	  local match_string='".*"'
	  local match_int='[0-9][0-9]*'
	  local match_qstring='"[^"\\]*(\\.[^"\\]*)*"' # NOTE: Adds 1 backreference

	  # get the name
	  xprop -id $window_id | \
		    sed -nr \
		        -e "s/^WM_CLASS\(STRING\) = ($match_qstring), ($match_qstring)$/instance=\1\nclass=\3/p" \
		        -e "s/^WM_WINDOW_ROLE\(STRING\) = ($match_qstring)$/window_role=\1/p" \
		        -e "/^WM_NAME\(STRING\) = ($match_string)$/{s//title=\1/; h}" \
		        -e "/^_NET_WM_NAME\(UTF8_STRING\) = ($match_qstring)$/{s//title=\1/; h}" \
		        -e '${g; p}'
}

shdl() { curl -O $(curl -s http://sci-hub.tw/"$@" | grep location.href | grep -o http.*pdf) ;}
se() { du -a ~/.local/bin/* ~/.config/* | awk '{print $2}' | fzf | xargs -r $EDITOR ;}
vf() { fzf | xargs -r -I % $EDITOR % ;}

# Return the number of processors available
nproc() {
  if $(which nproc >/dev/null 2>&1); then
    command nproc
  elif [ -e /proc/cpuinfo ]; then
    grep ^processor < /proc/cpuinfo | wc -l
  else
    sysctl -n hw.ncpu
  fi
}

# A friendlier cat that does not invoke a subshell.

kat () {
	declare line
  if [[ -z "$*" ]]; then
    while IFS= read -r line; do
      [[ $line =~ $exp ]] && echo "$line"
    done
    return
  fi
  for file in $*; do
    while IFS= read -r line; do
      echo "$line"
    done < "$file"
  done
}

# Same as kat but skips blank and lines with optional whitespace that
# begin with a comment character (#).

# katlines () {
#   for file in $*; do
#     while IFS= read -r line; do
#       [[ $line =~ ^\ *(#|$) ]] && continue
#       echo "$line"
#     done < "$file"
#   done
# }

# True if anything that can be run from the command line exists, binaries,
# scripts, aliases, and functions.

havecmd () {
  type "$1" &>/dev/null
  return $?
}

# Moves an existing thing to the same path and name but with
# ".preserved.<tstamp>" at the end and echoes the new location. Usually
# preferable to destroying what was previously there. Can be used to roll
# back changes transactionally.

preserve () {
  declare target="${1%/}"
  [[ ! -e "$target" ]] && return 1
  declare new="$target.preserved.$(tstamp)"
  mv "$target" "$new"
  echo "$new"
}

# Lists all the preserved files by matching the .preserved<tstamp> suffix.
# If passed an argument limits to only those preserved files matching that
# name (prefix).

lspreserved () {
  declare -a files
  if [[ -z "$1" ]]; then
      files=(*.preserved.[2-9][0-9][0-9][0-9][0-9][0-9][0-9][0-9][0-9][0-9][0-9][0-9][0-9][0-9])
  else
      files=("$1".preserved.[2-9][0-9][0-9][0-9][0-9][0-9][0-9][0-9][0-9][0-9][0-9][0-9][0-9][0-9])
  fi
  for i in "${files[@]}"; do
    echo "$i"
  done
}

lastpreserved () {
  mapfile -t  a < <(lspreserved "$1")
  declare n=${#a[@]}
  echo "${a[n-1]}"
}

rmpreserved () {
  while IFS= read -r line; do
    rm -rf "$line"
  done < <(lspreserved)
}

# Undos the last preserve performed on the given target.

unpreserve () {
  declare last=$(lastpreserved "$*")
  [[ -z "$last" ]] && return 1
  mv "$last" "${last%.preserved*}"
}

trash () {
  [[ -z "$TRASH" ]] && return 1
  mkdir -p "$TRASH"
  mv "$*" "$TRASH"
}

# confirm () {
#   declare yn
#   read -p " [y/N] " yn
#   [[ ${yn,,} =~ y(es)? ]] && return 0
#   return 1
# }

tell () {
  declare buf=$(argsorin "$*")
  mark $md_plain "$buf"
}

telln () {
  tell "$*"; echo
}

remind () {
  declare buf=$(argsorin "$*")
  tell "*REMEMBER:* $buf"
}

remindln () {
  remind "$*"; echo
}

danger () {
  declare buf=$(argsorin "$*")
  tell "${blinkon}***DANGER:***${blinkoff} $buf"
}

dangerln () {
  danger "$*"; echo
}

warn () {
  declare buf=$(argsorin "$*")
  tell "${yellow}WARNING:${reset} $buf"
}

warnln () {
  warn "$*"; echo
}

usageln () {
  declare cmd="$1"; shift
  declare buf="$*"
  tell "**usage:** *$cmd* $buf"
  echo
}


############################## Markdown-ish ##############################

# Minimal packrat parsing expression grammar (PEG):
#
#   Mark      <- Span* !.
#   Span      <- Plain / StrongEm / Strong / Emphasis / Link / Code
#   StrongEm  <- '***' .* '***'
#   StrongEm  <- '***' .* '***'
#   Strong    <- '**' .* '**'
#   Emphasis  <- '*' .* '*'
#   Link      <- '<' .* '>'
#   Code      <- '`' .* '`'
#   Plain     <- DQUOTE / QUOTE / LARROW / RARROW / ELLIPSIS / .*
#   DQUOTE    <- '"'
#   QUOTE     <- "'"
#   LARROW    <- " <- "
#   RARROW    <- " -> "
#   ELLIPSIS  <- '...'
#
# There's no character escape support because it isn't needed for most
# all use cases here.

export md_strongem=$red     #  ***strongem***
export md_strong=$yellow    #  **strong**
export md_emphasis=$magen   #  *emphasis*
export md_code=$cyan        #  `code`
export md_plain=''          #  plain

mark () {
  declare inemphasis instrong instrongem incode indquote inquote inlink i
  declare defsol1="$normal"
  declare defsol2="$normalbg"

  # Detect default colors (fore, bg) from optional first and second
  # arguments.

  issol "$1" && defsol1="$1" && shift
  issol "$1" && defsol2="$1" && shift
  declare defsol="$defsol1$defsol2"
  echo -n "$defsol"

  # The main content is almost always within single quotes to prevent
  # shell expansions, but we'll combine the remaining arguments anyway for
  # convenience (like echo does).

  declare buf=$*

  # recursive descent parser

  for (( i=0; i<${#buf}; i++ )); do

    # ***strongem***

    if [[ "${buf:$i:3}" = '***' ]]; then
      if [[ -z "$instrongem" ]]; then
        echo -n "$md_strongem"
        #echo -n '<strongem>'
        instrongem=1
      else
        #echo -n '</strongem>'
        echo -n $defsol
        instrongem=''
      fi
      i=$[i+2]
      continue
    fi

    # **strong**

    if [[ "${buf:$i:2}" = '**' ]]; then
      if [[ -z "$instrong" ]]; then
        echo -n "$md_strong"
        #echo -n '<strong>'
        instrong=y
      else
        #echo -n '</strong>'
        echo -n $defsol
        instrong=''
      fi
      i=$[i+1]
      continue
    fi

    # *emphasis*

    if [[ "${buf:$i:1}" = '*' ]]; then
      if [[ -z "$inemphasis" ]]; then
        echo -n "$md_emphasis"
        #echo -n '<emphasis>'
        inemphasis=y
      else
        #echo -n '</emphasis>'
        echo -n $defsol
        inemphasis=''
      fi
      continue
    fi

    # `code`

    if [[ "${buf:$i:1}" = '`' ]]; then
      if [[ -z "$incode" ]]; then
        echo -n "$md_code"
        #echo -n '<code>'
        incode=y
      else
        #echo -n '</code>'
        echo -n $defsol
        incode=''
      fi
      continue
    fi

    # "

    if [[ "${buf:$i:1}" = '"' ]]; then
      if [[ -z "$indquote" ]]; then
        echo -n '“'
        indquote=y
      else
        echo -n '”'
        indquote=''
      fi
      continue
    fi

    # '

    if [[ "${buf:$i:1}" = "'" ]]; then
      if [[ -z "$inquote" ]]; then
        echo -n '‘'
        inquote=y
      else
        echo -n '’'
        inquote=''
      fi
      continue
    fi

    # <-

    if [[ "${buf:$i:4}" = ' <- ' ]]; then
      echo -n " ← "
      i=$[i+3]
      continue
    fi

    # ->

    if [[ "${buf:$i:4}" = ' -> ' ]]; then
      echo -n " → "
      i=$[i+3]
      continue
    fi

    # ...

    if [[ "${buf:$i:3}" = '...' ]]; then
      echo -n "…"
      i=$[i+2]
      continue
    fi

    # <link>

    if [[ "${buf:$i:1}" = '<' ]]; then
      if [[ -z "$inlink" ]]; then
        echo -n $md_code${buf:$i:1}
        #echo -n '<link>'
        inlink=y
      fi
      continue
    fi
    if [[ "${buf:$i:1}" = '>' ]]; then
      if [[ -n "$inlink" ]]; then
        #echo -n '</link>'
        echo -n ${buf:$i:1}$defsol
        inlink=''
      fi
      continue
    fi

    echo -n "${buf:$i:1}"
  done
  echo -n $reset
}

############################### Date / Time ##############################

tstamp () {
  echo -n $1
  date '+%Y%m%d%H%M%S'
}

tstampfile () {
  declare path="$1"
  declare pre=${path%.*}
  declare suf=${path##*.}
  echo -n $pre.$(tstamp)
  [[  "$pre" != "$suf" ]] && echo .$suf
}

now () {
  echo "$1" $(date "+%A, %B %e, %Y, %l:%M:%S%p")
}

now-s () {
  echo "$1" $(date "+%A, %B %e, %Y, %l:%M %p")
}

epoch () {
  date +%s
}

watchnow () {
  declare -i delay="${1:-10}"
  havecmd setterm && setterm --cursor off
  trapterm 'setterm --cursor on; clear'
  while true; do
    clear
    echo -n $(now-s) |lolcat
    now-s > ~/.now
    sleep $delay
  done
}

weekday () {
  echo $(lower $(date +"%A"))
}

month () {
  echo $(lower $(date +"%B"))
}

year () {
  echo $(lower $(date +"%Y"))
}

week () {
  date +%W
}

# Calls the compact ncal variation with Mondays first and including the
# week count during the year. I prefer keeping track of blogs and such by
# the week of the year and not more complicated months and dates. (No one
# ever plugs in a specific month and day into a long blog URL. They just
# want it to be short).

cal () {
  declare exe=$(which ncal)
  if [[ -z "$exe" ]]; then
    cal $*
    return $?
  fi
  $exe -M -w $*
}

init_sdkman() {
    export SDKMAN_DIR="${HOME}/.sdkman"
    [[ -s "${SDKMAN_DIR}/bin/sdkman-init.sh" ]] && source "${SDKMAN_DIR}/bin/sdkman-init.sh"
    test -e "${HOME}/.iterm2_shell_integration.bash" && source "${HOME}/.iterm2_shell_integration.bash"
}

# Use lf to switch directories and bind it to ctrl-o
lfcd () {
    tmp="$(mktemp)"
    lf -last-dir-path="$tmp" "$@"
    if [ -f "$tmp" ]; then
        dir="$(cat "$tmp")"
        rm -f "$tmp" >/dev/null
      x [ -d "$dir" ] && [ "$dir" != "$(pwd)" ] && cd "$dir"
    fi
}
#bind -s '^o' 'lfcd\n'

# grep for processes
function pg { pgrep -fa "$1" | grep -E --color "$1"; }

rga-fzf() {
    RG_PREFIX="rga --files-with-matches"
    local file
    file="$(
        FZF_DEFAULT_COMMAND="$RG_PREFIX $@" \
            fzf --sort --preview="[[ ! -z {} ]] && rga --pretty --context 5 {q} {}" \
                --bind=tab:down,btab:up \
                --phony -q "$1" \
                --bind "change:reload:$RG_PREFIX {q}" \
                --preview-window="70%:wrap"
    )" &&
    echo "opening $file" &&
    xdg-open "$file"
}

switchgo() {
  version=$1
  if [ -z $version ]; then
    echo "Usage: switchgo [version]"
    return
  fi

  if ! command -v "go$version" > /dev/null 2>&1; then
    echo "version does not exist, downloading with commands: "
    echo "  go get golang.org/dl/go${version}"
    echo "  go${version} download"
    echo ""

    go get "golang.org/dl/go${version}"
    go${version} download
  fi

  go_bin_path=$(command -v "go$version")
  ln -sf "$go_bin_path" "$GOBIN/go"
  echo "Switched to ${go_bin_path}"
}

# only exit if we're not on the last pane
# TODO: Is this useful
# exit() {
#   if [[ -z $TMUX ]]; then
#     builtin exit
#     return
#   fi

#   panes=$(tmux list-panes | wc -l)
#   wins=$(tmux list-windows | wc -l)
#   count=$(($panes + $wins - 1))
#   if [ $count -eq 1 ]; then
#     tmux detach
#   else
#     builtin exit
#   fi
# }

pom() {
    local -r HOURS=${1:?}
    local -r MINUTES=${2:-0}
    local -r POMODORO_DURATION=${3:-25}

    echo "(($HOURS * 60) + $MINUTES) / $POMODORO_DURATION" | bc
}

ports() {
    sudo netstat -tulpn | grep LISTEN | fzf;
}

duckduckgo() {
    lynx -vikeys -accept_all_cookies "https://lite.duckduckgo.com/lite/?q=$@"
}

wikipedia() {
    lynx -vikeys -accept_all_cookies "https://en.wikipedia.org/wiki?search=$@"
}

#### Rancher #######
function ssh_aws() {
	ssh -o "StrictHostKeyChecking no" -i "${AWS_SSH_PATH}/<your_ssh_key>" -t "ubuntu@${1}" "sudo -s" "${@:2}"
}

function ssh_aws_with_key() {
	ssh -o "StrictHostKeyChecking no" -i "${2}" -t "ubuntu@${1}" "sudo -s" "${@:3}"
}

function scp_aws() {
	scp -i "${AWS_SSH_PATH}/<your_ssh_key>" -r "ubuntu@${1}:${2}" "${3}"
}

function aws_describe_instances() {
	aws ec2 describe-instances "${@:1}"
}

# describe aws instances matching Name tag, can pass additional Name/Value filter combos
function aws_describe_instances_by_name_and_filters() {
	aws_describe_instances --filters Name=tag:Name,Values="${1}" "${@:3}" --region "${2}"
}

# gets the public ips for Rancher nodes with matching "Name" tag and region
function aws_get_node_ips_by_instance_name() {
	aws_describe_instances_by_name_and_filters "${1}" "${2}" "${@:3}" | grep PublicIp: | awk '{print $2}' | uniq
}

function k8s_get_private_node_ips() {
	kubectl get nodes -o custom-columns=NAME:.metadata.name,IP:"{.status.addresses[?(@.type=='InternalIP')].address}" --selector='!monitoring' | awk 'NR > 1 {print $2}'
}

### k3s only
function rcli_reset_password_on_remote() {
	ssh_aws "${1}" "source /etc/profile; export KUBECONFIG=/etc/rancher/k3s/k3s.yaml; kubectl --kubeconfig \$KUBECONFIG -n cattle-system exec \$(kubectl --kubeconfig \$KUBECONFIG -n cattle-system get pods -l app=rancher | grep '1/1' | head -1 | awk '{ print \$1 }') -- reset-password | tail -n 1"
}

function rcli_forward_prometheus() {
	if [ -z "${1}" ]
	then
		kubectl port-forward -n cattle-monitoring-system service/rancher-monitoring-prometheus 8443:9090 "${@:1}"
	else
		kubectl port-forward -n cattle-monitoring-system service/rancher-monitoring-prometheus "${1}":9090 "${@:2}"
	fi

}

function rcli_forward_grafana() {
	if [ -z "${1}" ]
	then
		kubectl port-forward -n cattle-monitoring-system deployment/rancher-monitoring-grafana 8444:3000 "${@:1}"
	else
		kubectl port-forward -n cattle-monitoring-system deployment/rancher-monitoring-grafana "${1}":3000 "${@:2}"
	fi
}

function tfapply_rancher_in_region() {
	local knownsizes;
	local knownregions;
	knownsizes="small medium large xlarge xxlarge"
	knownregions="us-west-1 us-west-2 us-east-1 us-east-2"

	if contains "${knownsizes}" "${1}" ; then

		if contains "${knownregions}" "${2}" ; then
			declare -A SIZE_INSTANCE_MAP
			SIZE_INSTANCE_MAP=( [small]=large [medium]=xlarge [large]=2xlarge [xlarge]=4xlarge [xxlarge]=8xlarge)
			if [ -z "${3}" ]
			then
				tf workspace select "${1}-${2}" && tf apply -var-file="${2}.tfvars" -auto-approve -var="rancher_instance_type=m5.${SIZE_INSTANCE_MAP[$1]}"
			else
				tf workspace new "${3}" || tf workspace select "${3}"
				tf apply -var-file="${3}" -var="aws_region=${2}" -auto-approve -var="rancher_instance_type=m5.${SIZE_INSTANCE_MAP[$1]}" "${@:4}"
			fi
		else
			echo "Requested region not found in known regions."
		fi
	else
		echo "Requested size not found in known sizes."
	fi
}

function tfdestroy_rancher_in_region() {
	local knownsizes;
	local knownregions;
	knownsizes="small medium large xlarge xxlarge"
	knownregions="us-west-1 us-west-2 us-east-1 us-east-2"

	if contains "${knownsizes}" "${1}" ; then

		if contains "${knownregions}" "${2}" ; then
			declare -A SIZE_INSTANCE_MAP
			SIZE_INSTANCE_MAP=( [small]="large" [medium]="xlarge" [large]="2xlarge" [xlarge]="4xlarge" [xxlarge]="8xlarge")
			if [ -z "${3}" ]
			then
				tf workspace select "${1}-${2}" && tf destroy -var-file="${2}.tfvars" -auto-approve -var="rancher_instance_type=m5.${SIZE_INSTANCE_MAP[$1]}"
			else
				tf workspace select "${3}" && tf destroy -var-file="${3}" -var="aws_region=${2}" -auto-approve -var="rancher_instance_type=m5.${SIZE_INSTANCE_MAP[$1]}" "${@:4}" && tf workspace select "default" && tf workspace delete "${3}"
			fi
		else
			echo "Requested region not found in known regions."
		fi
	else
		echo "Requested size not found in known sizes."
	fi
}

function rapi_get_heap_logs() {
    for pod in $(kubectl -n cattle-system get pods --no-headers -l app=rancher | cut -d ' ' -f1); do
        echo getting profile for "${pod}"
        kubectl -n cattle-system exec "${pod}" -- curl -s http://localhost:6060/debug/pprof/heap -o profile.log
        kubectl -n cattle-system cp "${pod}:profile.log" "${pod}-heap.log"
        echo saved profile "${pod}-heap.log"
    done
}

function rapi_set_token_and_url() {
    export TF_VAR_rancher_token_key="${1}"
    export ADMIN_TOKEN="${1}"
    export TF_VAR_rancher_api_url="https://${2}.qa.rancher.space"
    export CATTLE_TEST_URL="https://${2}.qa.rancher.space"
}

function _rapi_get_leader_pod() {
    kubectl -n kube-system get configmap cattle-controllers -o jsonpath='{.metadata.annotations.control-plane\.alpha\.kubernetes\.io/leader}' "${@:1}" | jq '.holderIdentity' | tr -d '"'
}

function rapi_get_leader_node() {
    local leader_pod=$(_rapi_get_leader_pod "${@:1}")
    kubectl -n cattle-system get pod ${leader_pod} -o=custom-columns=NAME:.metadata.name,STATUS:.status.phase,NODE:.spec.nodeName "${@:1}"

}

function rapi_get_monitor_node() {
    kubectl get nodes -l monitoring=yes -o jsonpath='{.items[*].status.addresses[?(@.type=="InternalIP")].address}'
}

function rapi_get_logs() {
    kubectl -n cattle-system logs -l app=rancher -c rancher --timestamps --tail=3600 > rancher_logs.txt
}

function rapi_info_logging() {
    kubectl -n cattle-system get pods -l app=rancher --no-headers -o custom-columns=name:.metadata.name | while read rancherpod; do kubectl -n cattle-system exec $rancherpod -c rancher -- loglevel --set info; done
}

function rapi_debug_logging() {
    kubectl -n cattle-system get pods -l app=rancher --no-headers -o custom-columns=name:.metadata.name | while read rancherpod; do kubectl -n cattle-system exec $rancherpod -c rancher -- loglevel --set debug; done
}

function rapi_trace_logging() {
    kubectl -n cattle-system get pods -l app=rancher --no-headers -o custom-columns=name:.metadata.name | while read rancherpod; do kubectl -n cattle-system exec $rancherpod -c rancher -- loglevel --set trace; done
}

function rapi_rancher_logs() {
    kubectl -n cattle-system logs -l app=rancher -c rancher --follow
}

### kubectl get clusters.management.cattle.io  # find the cluster you want to delete
function rapi_force_delete_downstream() {
    # example: export CLUSTERID="c-xxxxxxxxx"
    export CLUSTERID="${1}"
    kubectl patch clusters.management.cattle.io $CLUSTERID -p '{"metadata":{"finalizers":[]}}' --type=merge
    kubectl delete clusters.management.cattle.io $CLUSTERID
}

### kubectl proxy in separate shell first
function rapi_force_delete_namespace() {
    NAMESPACE="${1}" \
    kubectl get ns $NAMESPACE -o json | \
    jq '.spec.finalizers=[]' | \
    curl -X PUT http://localhost:8001/api/v1/namespaces/$NAMESPACE/finalize -H "Content-Type: application/json" --data @-
}

#-------- Virtualbox CLI {{{
#------------------------------------------------------
# DESC: Virtualbox is a general-purpose full virtualizer for x86 hardware, targeted at server, desktop and embedded use
# https://www.howtoforge.com/tutorial/running-virtual-machines-with-virtualbox-5.1-on-a-headless-ubuntu-16.04-lts-server/

vbx-list() {
  echo "===Available VM==="
  vboxmanage list vms
  echo "\n===Running VM====="
  vboxmanage list runningvms
}

vbx-dvdrom() {
  if [ $# -lt 2 ]; then
    echo -e "Mount an ISO Image as a DVDROM/CDROM Image on a Running Virtualbox VM"
    echo -e "\nUsage: $0 <vmname> <iso_image>"
    echo -e "\nExample: $0 'Windows 7' 'foobar.iso'"
    echo "\n===Running VM====="
    vboxmanage list runningvms
    return 1
  fi

  vboxmanage storageattach "$1" --storagectl IDE --port 1 --device 0 --type dvddrive --medium "$2"
}

vbx-start() {
  # Set to endless loop
  while true
  do
    # Set the prompt for the select command
    PS3="Type a number to select or 'Ctrl+C' to quit: "

    # Create a list to display on menu
    IFS=$'\n'
    fileList=($(vboxmanage list vms | cut -d '{' -f1 | sed 's/ *$//'))
    unset IFS

    # Show a menu and ask for input. If the user entered a valid choice then execute command
    select fileName in $fileList; do
      if [ -n "$fileName" ]; then
        # remove quotes from filename
        vm_name=($(echo "${fileName}" | sed 's:\"::g' ))
		if [ "$1" = "headless" ]
		then
			vboxmanage startvm "$vm_name" --type headless
		else
			vboxmanage startvm "$vm_name"
		fi
        echo -e "${Green} $vm_name Has Been Started ${Color_Off}"
      fi
      break
    done
  done
}

vbx-quit() {
  # Set to endless loop
  while true
  do
    # Set the prompt for the select command
    PS3="Type a number to select or 'Ctrl+C' to quit: "

    # Create a list to display on menu
    IFS=$'\n'
    fileList=($(vboxmanage list runningvms | cut -d '{' -f1 | sed 's/ *$//'))
    unset IFS

    # Show a menu and ask for input. If the user entered a valid choice then execute command
    select fileName in $fileList; do
      if [ -n "$fileName" ]; then
        # remove quotes from filename
        vm_name=($(echo "${fileName}" | sed 's:\"::g' ))
        vboxmanage controlvm "$vm_name" acpipowerbutton
        echo -e "${Yellow} $vm_name Is Shutting Down ${Color_Off}"
      fi
      break
    done
  done
}

vbx-forcequit() {
  # Set to endless loop
  while true
  do
    # Set the prompt for the select command
    PS3="Type a number to select or 'Ctrl+C' to quit: "

    # Create a list to display on menu
    IFS=$'\n'
    fileList=($(vboxmanage list runningvms | cut -d '{' -f1 | sed 's/ *$//'))
    unset IFS

    # Show a menu and ask for input. If the user entered a valid choice then execute command
    select fileName in $fileList; do
      if [ -n "$fileName" ]; then
        # remove quotes from filename
        vm_name=($(echo "${fileName}" | sed 's:\"::g' ))
        vboxmanage controlvm "$vm_name" poweroff
        echo -e "${Red} $vm_name Power Cable Has Been Pulled ${Color_Off}"
      fi
      break
    done
  done
}
#}}}

#-------- listing functions CLI {{{
#------------------------------------------------------
# list and grep with file permissions
lsg() {
  keyword=$(echo "$@" |  sed 's/ /.*/g')
  \ls -hlA --color=yes \
  | awk '{k=0;for(i=0;i<=8;i++)k+=((substr($1,i+2,1)~/[rwx]/)*2^(8-i));if(k)printf(" %0o ",k);print}' \
  | \grep -iE $keyword
}

# ls recent items at bottom with green TODAY yellow YESTERDAY substituted with file permission also
# https://www.reddit.com/r/archlinux/comments/41s1w4/what_is_your_favorite_one_liner_to_use/cz50y1m
# http://askubuntu.com/a/152005
lst() {
  \ls -vAFq --color=yes -got --si --time-style=long-iso "$@" \
  | sed "s/$(date +%Y-%m-%d)/\x1b[32m     TODAY\x1b[m/;s/$(date +'%Y-%m-%d' -d yesterday)/\x1b[33m YESTERDAY\x1b[m/" \
  | awk '{k=0;for(i=0;i<=8;i++)k+=((substr($1,i+2,1)~/[rwx]/)*2^(8-i));if(k)printf(" %0o ",k);print}' | tac
}
#}}}

#-------- gitag function {{{
gtag() {
  git status 2>& /dev/null
  if [ $? -ne 0 ]; then
    echo "Not in a git repo"
    return 1
  fi
  echo "Continue to tag with '$1' and push '$1' to origin?"
  select choice in "Yes" "No"; do
    case $choice in
      Yes ) git tag "$1" && git push origin "$1"; break;;
      No ) exit;;
    esac
  done
}
#}}}

#-------- docker exec into container {{{
docker-attach() {
  docker exec -it $1 bash
}
#}}}

#-------- set permissisons recursively {{{
dirs_permissions() {
  find . -Type d -exec chmod $1 {} \;
}
files_permissions() {
  find . -type f -exec chmod $1 {} \;
}
#}}}

#-------- misc functions{{{
installdate() {
  ls --sort=t / -l | tail -n1 | awk '{print $8 " " $7 " " $6}'
}

freq_commands() {
  history | awk '{print $2};' | sort | uniq -c | sort -rn | head -10
}

metapdfrename() {
  exiftool '-filename<$title.%e .'
}

getfingerprint() {
  echo -n | openssl s_client -connect "$1" | openssl x509 -noout -fingerprint
}

unique_word_count() {
  tr -c "[:alnum:]" "[\n*]" < $1 | sort | uniq -c | sort -n$3 | head  -$2
}

make-bak() {
	cp -a "$1" "${1}_$(date --iso-8601=seconds)_bak"
}

# print a list of supported colors
function lscolors {
	((cols = $COLUMNS - 4))
	s=$(printf %${cols}s)
	for i in {000..$(tput colors)}; do
		echo -e $i $(tput setaf $i; tput setab $i)${s// /=}$(tput op);
	done
}

function hr {
	print ${(l:COLUMNS::=:)}
}

groot() {
  if [ "$(git rev-parse --is-inside-work-tree 2>/dev/null)" = "true" ]; then
    git rev-parse --show-toplevel
    return 0
  else
    echo "Not in git directory!"
    return 1
  fi
}

cdgroot() {
  cd $(groot)
}

dexec() {
  if (( $# == 0 ))
    then
        echo "usage: dexec <container name | container id>"
        return
  fi
  docker exec -it $1 sh
}


# Kubernetes helpers

# deploys a helm chart a number of times to a cluster pointed to by KUBECONFIG environment setting
function bulk_create_deployment() {
  ### $1 - number of deployments
  ### $2 - namespace to deploy to
  ### $3 - local chart dir or chart name to deploy
  for ((i = 0; i < $1; i++)); do
    helm install -n "${2}" --create-namespace --generate-name "${3}"
  done
}

# AWS helpers
# consider KEY_NAME global variable for ease of use
make_aws() {
	_instance_count="${1:-1}" # number of instances to make each run of the script
	_ami="${2:-0535d9b70179f9734}" # sles 15sp4
	_instance_type="${3:-t2.medium}"
	_ebs_size="${4:-35}"
	_key_name="${5:-$AWS_KEY_NAME}" #sometimes region dependent
	_random_num=$(jot -r 1 10 99)
	_name_tag='ResourceType=instance,Tags=[{Key=Name,Value=YOUR-NAME-'$_random_num'}]'
	#local path_to_config="file://~/path/to/configs/cloud-config.yaml"
	aws ec2 run-instances \
	--image-id ami-"$_ami" \
	--count "$_instance_count" \
	--instance-type "$_instance_type" \
	--key-name "$_key_name" \
	--security-group-ids sg-security-group-id \
	--subnet-id subnet-subnet-id \
	--block-device-mapping DeviceName=/dev/sda1,Ebs={VolumeSize="$_ebs_size"} \
	--tag-specifications "$_name_tag" \
	#--user-data "$path_to_config"
}

get_aws() {
    _greppies="${1:-pub}"
	_keyName="${2:-$AWS_KEY_NAME}"
	_region="${3:-us-east-2}"
    case "$_greppies" in
    all) aws ec2 --region "$_region" describe-instances --filter Name=key-name,Values="$_keyName" | grep -e InstanceId -e PublicIpAddress -e PrivateIpAddress -e Ipv6Address ;;
    pub) aws ec2 --region "$_region" describe-instances --filter Name=key-name,Values="$_keyName" | grep -e PublicIpAddress | awk '{print $2 ":    " $4}' ;;
    esac
}

drop_aws() { 
	aws ec2 terminate-instances \
	--instance-ids "$1" "$2" "$3" "$4" "$5"
}

drop_AAWS() {
	_keyName="${1:-$AWS_KEY_NAME}"
	# shellcheck disable=SC2000-SC4000
	if [ -z "$_keyName" ]
	then
		echo "keyName variable is empty..."
	else
	    _ARRAY=($(aws ec2 describe-instances --filter Name=key-name,Values="$_keyName" | grep -i -e InstanceId | awk '{print $4}'));
		echo "$_ARRAY"
    	for id in "${_ARRAY[@]}"
			do
				drop_aws "$id" 
			done
	fi
}

get_mylb() {
	_prefixer="${1:-usually-firstname-twice}"
	aws elbv2 describe-load-balancers | grep -e "$_prefixer" | grep -e LoadBalancerArn | awk '{print $2};END{print NR " Total LoadBalancers"}'
}

get_awslb() {
	aws elbv2 describe-load-balancers | grep -e LoadBalancerArn | awk '{print $2 ":    " $4};END{print NR " Total LoadBalancers"}' | sort
}

get_lbname(){
	 aws elbv2 describe-load-balancers | grep -i -e LoadBalancerName | awk '{print $2 ":  " $4};END{print NR " Total LoadBalancers"}' | sort
}

drop_awslb(){
	aws elbv2 delete-load-balancer --load-balancer-arn "$1" # aws cli doesn't seem to support multiple arns? 
}

# Delete a given line number in the known_hosts file.
knownrm() {
 re='^[0-9]+$'
 if ! [[ $1 =~ $re ]] ; then
   echo "error: line number missing" >&2;
 else
   sed -i "$1d" ~/.ssh/known_hosts
 fi
}

# Open yazi and change to currently browesed directory when exiting
function y() {
	local tmp="$(mktemp -t "yazi-cwd.XXXXXX")" cwd
	yazi "$@" --cwd-file="$tmp"
	if cwd="$(command cat -- "$tmp")" && [ -n "$cwd" ] && [ "$cwd" != "$PWD" ]; then
		builtin cd -- "$cwd"
	fi
	rm -f -- "$tmp"
}

kctx() {
  (
    cd ~/.kube/ || exit 1
    # shellcheck disable=SC2012
    KUBE=$(ls kube-* | fzf)
    [[ -n "$KUBE" ]] && ln -sf "$KUBE" config
  )
}

klctx() {
    # shellcheck disable=SC1083
    local SEARCH="${1:-$HOME/Downloads}"
    [[ "$1" == "-" ]] && SEARCH="$HOME/.kube"
    local KUBE=$(ls "$SEARCH" -p -t | grep -v / | fzf)
    if [[ -n "$KUBE" ]]; then
      export KUBECONFIG="${SEARCH%/}/$KUBE"
    fi
}
